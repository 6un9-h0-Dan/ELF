/**
 * Copyright (c) 2018-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

#pragma once

#include <fstream>
#include <iostream>
#include <mutex>
#include <string>
#include <vector>

#include <nlohmann/json.hpp>
#include "model_pair.h"

#include "../base/board.h"
#include "../base/common.h"

struct MsgVersion {
  int64_t model_ver;
  MsgVersion(int ver = -1) : model_ver(ver) {}
};

struct Request {
  ModelPair vers;
  float resign_thres = 0.0;
  float never_resign_prob = 0.0;

  bool player_swap = false;
  bool async = false;

  // -1 means using all threads.
  int num_game_thread_used = -1;

  void setJsonFields(json& j) const {
    JSON_SAVE_OBJ(j, vers);
    JSON_SAVE(j, resign_thres);
    JSON_SAVE(j, never_resign_prob);
    JSON_SAVE(j, player_swap);
    JSON_SAVE(j, async);
    JSON_SAVE(j, num_game_thread_used);
  }

  static Request createFromJson(const json& j) {
    Request request;
    JSON_LOAD_OBJ(request, j, vers);
    // What does the following do?
    // JSON_LOAD_OBJ(request, j, client_ctrl, request.vers.is_selfplay());
    JSON_LOAD(request, j, resign_thres);
    JSON_LOAD(request, j, never_resign_prob);
    JSON_LOAD(request, j, player_swap);
    JSON_LOAD(request, j, async);
    JSON_LOAD(request, j, num_game_thread_used);
    return request;
  }

  std::string dumpJsonString() const {
    json j;
    setJsonFields(j);
    return j.dump();
  }

  std::string info() const {
    std::stringstream ss;
    ss << "[async=" << async << "]"
       << "[res_th=" << resign_thres << "][swap=" << player_swap
       << "][never_res_pr=" << never_resign_prob << "]"
       << "][#th=" << num_game_thread_used << "]";
    return ss.str();
  }

  friend bool operator==(const Request& r1, const Request& r2) {
    return r1.resign_thres == r2.resign_thres &&
      r1.never_resign_prob == r2.never_resign_prob &&
      r1.player_swap == r2.player_swap &&
      r1.async == r2.async &&
      r1.num_game_thread_used == r2.num_game_thread_used;
  }

  friend bool operator!=(const Request& r1, const Request& r2) {
    return !(r1 == r2);
  }
};

struct CoordRecord {
    unsigned char prob[BOUND_COORD];
};

inline void from_json(const json &j, CoordRecord &cr) {
  for (size_t k = 0; k < j.size(); k++) {
    cr.prob[k] = j[k];
  }
}

inline void from_json(const json &j, std::vector<CoordRecord> &cr) {
  cr.clear();
  for (size_t i = 0; i < j.size(); i ++) {
    cr.emplace_back();
    for (size_t k = 0; k < j[i].size(); k++) {
      cr[i].prob[k] = j[i][k];
    }
  }
}

inline void to_json(json &j, const CoordRecord &cr) {
  for (unsigned char c : cr.prob) {
    j.push_back(c);
  }
};


struct Result {
  int num_move = 0;
  float reward = 0.0;
  bool never_resign = false;
  // Whether this replay is generated by mutliple models.
  std::vector<int64_t> using_models;
  std::string content;
  std::vector<CoordRecord> policies;
  std::vector<float> values;

  std::string info() const {
    std::stringstream ss;
    ss << "[num_move=" << num_move << "]";
    ss << "[models=";
    for (const auto& i : using_models)
      ss << i << ", ";
    ss << "]";
    ss << "[reward=" << reward << "][no_res=" << never_resign
       << "] len(content)=" << content.size();
    return ss.str();
  }

  void setJsonFields(json& j) const {
    JSON_SAVE(j, num_move);
    JSON_SAVE(j, reward);
    JSON_SAVE(j, never_resign);
    JSON_SAVE(j, using_models);
    JSON_SAVE(j, content);

    for (size_t i = 0; i < policies.size(); i++) {
      json j1;
      for (unsigned char c : policies[i].prob) {
        j1.push_back(c);
      }
      j["policies"].push_back(j1);
    }

    JSON_SAVE(j, values);
  }

  static Result createFromJson(const json& j) {
    Result res;

    // cout << "extract num_moves" << endl;
    JSON_LOAD(res, j, num_move);
    JSON_LOAD(res, j, reward);
    JSON_LOAD(res, j, content);
    JSON_LOAD(res, j, never_resign);
    JSON_LOAD_VEC_OPTIONAL(res, j, using_models);
    JSON_LOAD_VEC(res, j, values);

    if (j.find("policies") != j.end()) {
      // cout << "extract policies" << endl;
      size_t num_policies = j["policies"].size();
      // cout << "Content: " << r.content << endl;
      //
      for (size_t i = 0; i < num_policies; i++) {
        json j1 = j["policies"][i];
        res.policies.emplace_back();
        for (size_t k = 0; k < j1.size(); k++) {
          res.policies.back().prob[k] = j1[k];
        }
      }
      // cout << "extract policies complete: " << num_policies << endl;
    }
    // cout << "#policies: " << num_policies << " #entries: " << total_entries
    //     << ", entries/policy: " << (float)(total_entries) / num_policies <<
    //     endl;
    return res;
  }
};

